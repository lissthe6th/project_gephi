# project_gephi
Учимся составлять базы данных для gephi gephi при помощи python и анализируем результат.

## Обзор Gephi.

Основным инструментом для своего исследования я выбрала программу Gephi. 

Giphi это средство визуализации графиков и сетей. 

Разработчики заявляют, что программа подходит для

- исследовательского анализа данных
- анализа связей
- анализа социальных сетей
- анализа биологических сетей
- создание высококачественных печатных карт-плакатов.

Чтобы быстро изучить особенности программы я окунулась в удивительный мир видео-объяснений. Однако они в основном были посвящены тому, как обрабатывать данные непосредественно в самой программе.

### В каком виде загружаются данные

Программа обрабатывает два основных файла.

![Информация об узлах](http://images.vfl.ru/ii/1634810450/8a247d59/36353517.png)	
![Информация о ребрах](http://images.vfl.ru/ii/1634810747/d62484bc/36353582.png)

Первый файл содержит информацию об узлах графов: id, label.

Второй файл содержит информацию о ребрах, то есть о связях между вершинами:
Source. Откуда
Target. Куда
Type. Directed / undirected
Weight. Вес связи

Чтобы разобраться с тем, как работает программа, необходимо создать или найти базу данных, на примере которой можно научиться пользоваться данным инструментом.

Но поскольку в процессе научения нужно решить конкретно-культурологическую задачу, большая часть времени у меня ушла на составление непосредственно базы данных. 

Итак, после определения базы данных и создания гипотезы, пора выстраивать логику работы и искать материал для обработки.

## Исследование. Подготовка.

Я решила провести эксперимент и написать базовую часть кода, которая помогла бы мне в обработке материала. 

Исходя из гипотезы я решила взять за материал список из нон-фикшн книг, собранную неким Robert McCrum на станицах The Guardian. Посмотреть сам список можно [по ссылке.](https://www.theguardian.com/books/2017/dec/31/the-100-best-nonfiction-books-of-all-time-the-full-list)  Англоязычный текст изначально мне казался более простым в использовани, поскольку в нем гораздо меньше окончаний и нет падежей. Для эксперимента — пойдет. 

Особо не мудрствуя, я просто скопипастила весь текст со списоком в отдельный блокнот и положила его в папку с проектом PyCharm.

![Первоначальный текст](http://images.vfl.ru/ii/1634811064/32a84679/36353645.png)

Полученный текст необходимо, конечно, почистить. До знакомства с питоном мне много раз приходилось чистить подобные списки руками. Ну, или с использовнием найти-заменить в ворде. Но это очень долго и муторно. 

Как говорят в тиктоке: если стоит выбор между тем, чтобы сделать работу за час или автоматизтировать её 6 часов — выбор очевиден, докажи миру, что ты программист.

В тексте прослеживается определенный словестный паттерн. Номер строчки в списке, название книги, автор, год, комментарий. Однако кроме позиций топ-100 мы видим там комментарии, которые автор статьи оставил для нашего кругозора и визуального разнообразия. Их я всё-таки удалила вручную.


## Подготовка кода.

### Первый код. Английский текст.

Полный код можно посмотреть здесь — ссылка.

Логика была такой:

1. Выделить паттерн в тексте, чтобы оставить только название - автор - год. Эти данные могут потребовтаься для других визуализаций, сейчас мы будем использовать только названия.
2. Разбить названия книг на слова.
3. Зафиксировать связи между словами в названии: как часто одни и те же слова встречаются в различных заголовках. 
4. Если уже существующие сочетания встречаются снова — увеличиваем вес связей.

---

**Подготовка материала.**

Выделив паттерн в тексте, начинаю писать код. Сначала мы делим текст построчно, чтобы работать с каждой линией рейтинга отдельно.

```python
for line in ifile.read().lower().split("\n"):
    if line:
        array_books.append(line)
```

А затем меняем все «маячки» паттерна на разделитель, который будем использовать. В данном случае мы разделяем по закрываюзей скобочке даты написания произведения. В arr у нас лежит вся строчка, поделенная на начало - дата - все остальное. В темп же кладем уже только нужное: название - автор - дата. Все это сохраняется в books.
